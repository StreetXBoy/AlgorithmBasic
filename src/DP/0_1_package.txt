  01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为C1，C2，…，Cn，与之相对应的价值为W1,W2，…，Wn.求解将那些物品装入背包可使总价值最大。
https://www.cnblogs.com/bewolf/p/4776880.html
动态规划：

  1） 子问题定义：F[i][j]表示前i件物品中选取若干件物品放入剩余空间为j的背包中所能得到的最大价值。

  2） 根据第i件物品放或不放进行决策


设物品件数为N，背包容量为V，第i件物品体积为C[i]，第i件物品价值为W[i]。



if(k<C[i])//如果第i个物品的体积已经大于背包剩余容量
        then   F[i][k] ← F[i-1][k]
else    F[i][k] ← max(F[i-1][k],F[i-1][k-C[i]]+W[i])


观察伪代码可也发现，F[i][j]只与F[i-1][j]和F[i-1][j-C[i]]有关，即只和i-1时刻状态有关，所以我们只需要用一维数组F[]来保存i-1时的状态F[]。假设i-1时刻的F[]为{a0，a1，a2，…，av}，难么i时刻的F[]中第k个应该为max(ak,ak-C[i]+W[i])即max(F[k],F[k-C[i]]+W[i])，
这就需要我们遍历V时逆序遍历，这样才能保证求i时刻F[k]时F[k-C[i]]是i-1时刻的值。
如果正序遍历则当求F[k]时其前面的F[0],F[1]，…，F[K-1]都已经改变过，里面存的都不是i-1时刻的值，
这样求F[k]时利用F[K-C[i]]必定是错的值。最后F[V]即为最大价值。


F[] ← {0}

     for i ← 1 to N

         do for k ← V to C[i]

             F[k] ← max(F[k],F[k-C[i]]+W[i])

     return F[V]



完全背包(要求背包必须装满，而不是最大限度的装)

主要是在01背包的初始化过程中的不同，然后考虑第i个物体的时候判断下是否可以装满的条件

F[][] ← {-1}

       F[][0] ← {0}

       for i←1 to N

           do for k←1 to V
                 if (F[i-1][k-C[i]]!=-1)
                       then

                            F[i][k] ← F[i-1][k]

                            if(k >= C[i])

                                   then F[i][k] ← max(F[i][k],F[i-1][k-C[i]]+W[i])

      return F[N][V]


物品无限的背包问题

将01背包一维数组解法中j的遍历顺序do for k←V to C[i]改为do for k←C[i] to V 就变成了物品无限背包的解法。






